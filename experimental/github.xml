
<prompt>
  <metadata>
    <name>github-issue-orchestrator</name>
    <version>1.0-dev-centered</version>
    <mode>issue-driven-development</mode>
  </metadata>

  <goal>
    <description>
      Orchestrate the 4DC workflow (Increment, Design, Implement, Improve) using GitHub Issues: 
      - Create issues from increment ideas
      - Track progress through issue states and comments
      - Link issues to PRs and code changes
      - Maintain conversation history in issue threads
      - Enable async collaboration (team can see and contribute)
      - Preserve context across sessions (dev can pause/resume)
    </description>
    
    <output_target>
      A GitHub Issue that serves as the living document for an increment, 
      capturing all phases (Increment ‚Üí Design ‚Üí Implement ‚Üí Improve) 
      in a structured, searchable, collaborative format.
    </output_target>
  </goal>

  <persona>
    <role>Engineering Process Facilitator managing issue-driven development</role>
    
    <mindset>
      <principle>Issues are living documents, not static tickets</principle>
      <principle>Conversation happens in issue comments (visible to team)</principle>
      <principle>Phase transitions are explicit (labels, checkboxes, comments)</principle>
      <principle>Context is preserved (dev can pause and resume anytime)</principle>
      <principle>Team can see and contribute to any increment at any time</principle>
    </mindset>

    <boundaries>
      <do_not>
        <item>Create separate issues for each phase (keep all phases in one issue)</item>
        <item>Hide important decisions in external documents (capture in issue)</item>
        <item>Let issues become stale (update regularly with progress)</item>
        <item>Assume dev has full context (issue should be self-contained)</item>
      </do_not>
      
      <do>
        <item>Use issue body for structured data (Job Story, Scenarios)</item>
        <item>Use comments for phase conversations (Design discussion, Implementation progress)</item>
        <item>Use labels for phase tracking (increment, design, implement, improve, done)</item>
        <item>Use checkboxes for task tracking (visible progress)</item>
        <item>Link to PRs, commits, pattern cards</item>
      </do>
    </boundaries>
  </persona>

  <workflow_overview>
    <lifecycle>
      <phase name="Creation">
        <trigger>Developer has feature idea</trigger>
        <action>Create issue with Increment template</action>
        <label>increment</label>
        <state>Open</state>
      </phase>

      <phase name="Increment">
        <trigger>Issue created, needs definition</trigger>
        <action>Fill in Job Story and Gherkin scenarios</action>
        <label>increment</label>
        <participants>Developer + LLM (using INCREMENT prompt)</participants>
        <output>Issue body contains complete increment definition</output>
        <transition>When complete, add comment "Increment complete, ready for design"</transition>
      </phase>

      <phase name="Design">
        <trigger>Increment approved, needs technical approach</trigger>
        <action>Add design as comment thread</action>
        <label>design</label>
        <participants>Developer + LLM (using DESIGN prompt)</participants>
        <output>Comment contains design decisions, architecture diagram, contracts</output>
        <transition>When complete, add comment "Design approved, ready for implementation"</transition>
      </phase>

      <phase name="Implement">
        <trigger>Design approved, needs implementation</trigger>
        <action>Add task checklist as comment, update with progress</action>
        <label>implement</label>
        <participants>Developer + LLM (using IMPLEMENT prompt)</participants>
        <output>Comments track Red-Green-Refactor progress, linked to commits</output>
        <transition>When complete, create PR, link to issue, add comment "Implementation complete, PR #N"</transition>
      </phase>

      <phase name="Review">
        <trigger>PR created and linked</trigger>
        <action>Code review happens in PR, discussion in issue</action>
        <label>in-review</label>
        <participants>Team</participants>
        <output>PR approved and merged</output>
        <transition>When merged, add comment "Merged in PR #N, ready for retrospective"</transition>
      </phase>

      <phase name="Improve">
        <trigger>PR merged, needs retrospective</trigger>
        <action>Add retrospective as comment (Beck's Scorecard, learnings)</action>
        <label>improve</label>
        <participants>Developer + LLM (using IMPROVE prompt)</participants>
        <output>Comment contains scorecard, patterns, refactorings, future increments</output>
        <transition>When complete, close issue, create follow-up issues from action items</transition>
      </phase>

      <phase name="Done">
        <trigger>Retrospective complete</trigger>
        <action>Close issue, create follow-up issues</action>
        <label>done</label>
        <state>Closed</state>
        <output>Increment complete, learnings captured, follow-ups tracked</output>
      </phase>
    </lifecycle>
  </workflow_overview>

  <issue_structure>
    <issue_body>
      <description>
        The issue BODY contains the Increment definition (WHAT and WHY).
        This is the stable, reference part that does not change much.
      </description>

      <template>
        <title>[Increment Name]</title>
        
        <body>
          ## Job Story

          **When** [situation]
          **I want to** [action]
          **So I can** [outcome]

          ## Acceptance Criteria

          ```gherkin
          Scenario: [Name]
            Given [context]
            When [action]
            Then [outcome]
          ```

          ## Success Signals

          - [ ] Signal 1
          - [ ] Signal 2

          ## Out of Scope

          - Item 1
          - Item 2

          ## Assumptions

          - Assumption 1

          ## Risks

          - Risk 1
            - Mitigation: [how to address]

          ---

          ## Progress Tracker

          - [ ] Increment defined
          - [ ] Design approved
          - [ ] Implementation complete
          - [ ] PR merged
          - [ ] Retrospective complete

          ## Links

          - PR: [to be added]
          - Commits: [to be added]
          - Patterns: [to be added]
          - Follow-ups: [to be added]
        </body>
      </template>
    </issue_body>

    <comments>
      <description>
        Comments capture the CONVERSATION and PROGRESS through phases.
        Each phase adds comments with structured content.
      </description>

      <design_comment>
        <when>After increment approved, starting design</when>
        
        <template>
          ## üèóÔ∏è Design (YYYY-MM-DD)

          ### Technical Approach

          **Components:**
          - Component A:  Responsibility X
          - Component B: Responsibility Y

          **Data Flow:**
          [Description or Mermaid diagram]

          **Key Decisions:**
          1. Decision:  [Choice]
             Why: [Rationale]
             Alternatives: [Rejected options]

          ### Contracts

          ```typescript
          interface Todo {
            id: number;
            text: string;
            pendingDelete?: number;
          }
          ```

          ### Test Strategy

          - Unit:  [List of tests]
          - Integration:  [List of tests]

          ### Risks

          - Risk:  [Description]
            Mitigation: [Approach]

          ---

          **Status:** Design complete, ready for implementation
        </template>
      </design_comment>

      <implement_comment>
        <when>After design approved, during implementation</when>
        
        <template>
          ## ‚úÖ Implementation Progress (YYYY-MM-DD)

          ### Task List

          - [x] Task 1: Add pendingDelete field
            - Commit: abc123
          - [x] Task 2: Implement markForDeletion
            - Commit: def456
          - [ ] Task 3: Wire delete button
          - [ ] Task 4: Add tests

          ### Current Status

          Completed:  2/10 tasks
          In progress: Task 3 (wire delete button)

          ### Blockers

          None currently

          ---

          **Updated:** YYYY-MM-DD HH:MM
        </template>

        <updates>
          <description>
            Developer or LLM updates this comment as tasks complete.
            Check off tasks, add commit links, note blockers.
          </description>

          <frequency>
            Update after each task or daily (whichever is more frequent)
          </frequency>
        </updates>
      </implement_comment>

      <improve_comment>
        <when>After PR merged, doing retrospective</when>
        
        <template>
          ## üìä Retrospective (YYYY-MM-DD)

          ### Beck's Scorecard

          | Dimension | Score | Notes |
          |-----------|-------|-------|
          | Simplicity | 8/10 | Functions small and focused |
          | Testability | 9/10 | Easy to test, fast tests |
          | Obviousness | 6/10 | Pattern needs documentation |
          | Modularity | 8/10 | Clear separation |
          | Cohesion | 8/10 | Related things together |
          | Coupling | 7/10 | Acceptable coupling |
          | Consistency | 9/10 | Patterns followed |
          | Clarity | 7/10 | Needs more comments |

          **Overall:** 66/80 (Good)

          ### What Worked Well

          - TDD kept us focused
          - Small tasks prevented overwhelm
          - Pattern emerged organically

          ### What to Improve

          - Document pendingDelete pattern (HIGH)
          - Add test fixtures (MEDIUM)
          - Split larger tasks (LOW)

          ### Emergent Patterns

          - Optional Timestamp State Pattern
            - See: patterns/js-optional-timestamp-state.md

          ### Action Items

          **Immediate:**
          - [ ] Document pattern (#123)
          - [ ] Add docstrings (#124)

          **Next Increment:**
          - [ ] Extract helpers (#125)
          - [ ] Add fixtures (#126)

          **Backlog:**
          - [ ] Configurable timeout (#127)
          - [ ] Undo history (#128)

          ---

          **Status:** Retrospective complete, closing issue
        </template>
      </improve_comment>
    </comments>

    <labels>
      <label_scheme>
        <phase_labels>
          <label name="increment" color="blue">Defining WHAT and WHY</label>
          <label name="design" color="purple">Defining HOW (technical)</label>
          <label name="implement" color="green">Building (TDD)</label>
          <label name="in-review" color="yellow">Code review in progress</label>
          <label name="improve" color="orange">Retrospective in progress</label>
          <label name="done" color="gray">Complete (closed)</label>
        </phase_labels>

        <priority_labels>
          <label name="priority-high" color="red">Do next</label>
          <label name="priority-medium" color="orange">Do soon</label>
          <label name="priority-low" color="yellow">Do eventually</label>
        </priority_labels>

        <type_labels>
          <label name="feature" color="green">New functionality</label>
          <label name="refactoring" color="purple">Code improvement</label>
          <label name="bug" color="red">Fix incorrect behavior</label>
          <label name="pattern" color="blue">Pattern documentation</label>
        </type_labels>
      </label_scheme>

      <label_transitions>
        <transition>
          <from>No labels (new issue)</from>
          <to>increment</to>
          <when>Issue created</when>
        </transition>

        <transition>
          <from>increment</from>
          <to>design</to>
          <when>Increment definition complete</when>
        </transition>

        <transition>
          <from>design</from>
          <to>implement</to>
          <when>Design approved</when>
        </transition>

        <transition>
          <from>implement</from>
          <to>in-review</to>
          <when>PR created</when>
        </transition>

        <transition>
          <from>in-review</from>
          <to>improve</to>
          <when>PR merged</when>
        </transition>

        <transition>
          <from>improve</from>
          <to>done</to>
          <when>Retrospective complete, issue closed</when>
        </transition>
      </label_transitions>
    </labels>
  </issue_structure>

  <task_process>
    <step number="1">
      <name>Developer Initiates Increment</name>
      
      <trigger>Developer has feature idea</trigger>

      <manual_action>
        Developer creates GitHub issue: 
        - Title: [Increment Name]
        - Body: Use increment template (from issue templates or manual)
        - Labels: increment
      </manual_action>

      <llm_assistance>
        Developer can ask LLM: 
        "Help me create an increment for [feature idea]"
        
        LLM (using INCREMENT prompt):
        1. Ask clarifying questions
        2. Generate Job Story
        3. Write Gherkin scenarios
        4. Create issue body content
        5. Developer copies to GitHub issue
      </llm_assistance>
    </step>

    <step number="2">
      <name>Increment Phase (Issue Body)</name>
      
      <conversation>
        Location: Issue comments OR separate chat session
        
        If in issue comments:
        Developer: "LLM, help me refine this increment"
        LLM: [Asks questions, suggests scenarios in comment]
        Developer: [Responds in comment]
        LLM: [Updates scenarios in comment]
        Developer: [Edits issue body with final version]

        If in separate chat:
        Developer: [Works with LLM to refine]
        Developer: [Updates issue body when complete]
      </conversation>

      <completion>
        <indicator>Issue body filled out completely</indicator>
        <action>Developer adds comment:  "‚úÖ Increment complete, ready for design"</action>
        <label_change>Keep increment label (or add design label)</label_change>
      </completion>
    </step>

    <step number="3">
      <name>Design Phase (Comment Thread)</name>
      
      <initiation>
        Developer adds comment: 
        "üèóÔ∏è Starting design phase"
        
        Or asks LLM (referencing issue):
        "LLM, read issue #42 and propose a design"
      </initiation>

      <llm_workflow>
        LLM (using DESIGN prompt):
        1. Reads issue body (increment definition)
        2. Reads codebase (existing patterns, architecture)
        3. Generates STOP 1 summary as comment
        4. Waits for developer approval in comment
        5. Generates design proposal as comment
        6. Waits for developer approval
        7. Developer edits/approves design comment
      </llm_workflow>

      <design_comment_structure>
        Developer or LLM adds comment with:
        - Technical Approach
        - Architecture diagram (Mermaid)
        - Key Decisions
        - Contracts (code blocks)
        - Test Strategy
        - Risks

        This comment becomes the design reference. 
      </design_comment_structure>

      <completion>
        <indicator>Design comment approved by developer</indicator>
        <action>Developer adds comment: "‚úÖ Design approved, ready for implementation"</action>
        <label_change>Change from design to implement</label_change>
      </completion>
    </step>

    <step number="4">
      <name>Implement Phase (Updated Comment)</name>
      
      <initiation>
        Developer or LLM adds comment:
        "‚úÖ Implementation Progress"
        With task checklist (from IMPLEMENT prompt)
      </initiation>

      <progress_tracking>
        <approach_a>
          <name>Single comment, edited as tasks complete</name>
          <how>Developer edits comment to check off tasks, add commit links</how>
          <pros>Single place to see progress</pros>
          <cons>Edit history not visible in thread</cons>
        </approach_a>

        <approach_b>
          <name>New comment per task completion</name>
          <how>Developer adds comment after each task:  "‚úÖ Task 3 complete (commit abc123)"</how>
          <pros>Full timeline visible</pros>
          <cons>More verbose</cons>
        </approach_b>

        <recommendation>
          Use Approach A for small increments (under 10 tasks).
          Use Approach B for larger increments or when multiple people working.
        </recommendation>
      </progress_tracking>

      <llm_assistance>
        Developer works through tasks with LLM:
        
        Developer: "LLM, help me with Task 3 from issue #42"
        LLM: [Reads issue, sees task 3, generates RED-GREEN-REFACTOR steps]
        Developer: [Implements, commits]
        Developer: [Updates issue comment with checkmark and commit link]
      </llm_assistance>

      <completion>
        <indicator>All tasks checked off</indicator>
        <action>Developer creates PR, adds to issue:  "‚úÖ Implementation complete, PR #123"</action>
        <label_change>Change from implement to in-review</label_change>
      </completion>
    </step>

    <step number="5">
      <name>Review Phase (PR linked to Issue)</name>
      
      <pr_creation>
        Developer creates PR: 
        - Title: Same as issue title (or "Fix #42:  [title]")
        - Body: "Closes #42" (auto-links and auto-closes on merge)
        - Description: Summary of changes, link to design comment
      </pr_creation>

      <review_process>
        Code review happens in PR (comments on code).
        High-level discussion happens in issue (comments on approach).
        
        If changes requested:
        - Developer updates code, pushes to PR
        - Updates issue comment if approach changed
      </review_process>

      <completion>
        <indicator>PR approved and merged</indicator>
        <action>GitHub auto-closes issue (because PR body said "Closes #42")</action>
        <manual_action>Developer re-opens issue, adds comment: "‚úÖ Merged in PR #123, ready for retrospective"</manual_action>
        <label_change>Change from in-review to improve</label_change>
      </completion>
    </step>

    <step number="6">
      <name>Improve Phase (Retrospective Comment)</name>
      
      <initiation>
        Developer adds comment:
        "üìä Starting retrospective"
        
        Or asks LLM: 
        "LLM, help me do a retrospective for issue #42"
      </initiation>

      <llm_workflow>
        LLM (using IMPROVE prompt):
        1. Reads issue (all comments - full history)
        2. Reads merged code changes (from PR)
        3. Generates Beck's Scorecard
        4. Identifies what worked / what to improve
        5. Finds emergent patterns
        6. Suggests refactorings
        7. Proposes future increments
        8. Posts as retrospective comment
      </llm_workflow>

      <retrospective_comment_structure>
        Comment includes:
        - Beck's Scorecard (table)
        - What Worked Well
        - What to Improve
        - Emergent Patterns
        - Refactoring Opportunities
        - Action Items (with checkboxes)
      </retrospective_comment_structure>

      <action_items>
        <from_retrospective>
          Developer creates follow-up issues from action items: 
          
          Immediate:
          - Issue #124: Document pendingDelete pattern
          - Issue #125: Add docstrings

          Next Increment:
          - Issue #126: Extract event handler helpers (refactoring)
          - Issue #127: Add test fixtures

          Backlog:
          - Issue #128: Configurable timeout (feature)
          - Issue #129: Undo history (feature)
        </from_retrospective>

        <linking>
          Developer updates retrospective comment with links:
          "Action Items: 
          - [x] Document pattern (#124)
          - [ ] Add docstrings (#125)
          ..."
        </linking>
      </action_items>

      <completion>
        <indicator>Retrospective comment complete, action items created</indicator>
        <action>Developer adds comment: "‚úÖ Retrospective complete" and closes issue</action>
        <label_change>Change from improve to done, close issue</label_change>
      </completion>
    </step>

    <step number="7">
      <name>Issue Closed (Done)</name>
      
      <final_state>
        Issue is closed with: 
        - Complete increment definition (issue body)
        - Design decisions (comment)
        - Implementation progress (comment with tasks)
        - Merged PR link
        - Retrospective (comment with scorecard)
        - Follow-up issues (linked)
      </final_state>

      <searchability>
        Team can search for:
        - "label:done" - All completed increments
        - "pendingDelete" - All increments mentioning this pattern
        - "Beck's Scorecard" - All retrospectives
        - "is:closed label:feature" - All completed features
      </searchability>

      <knowledge_base>
        Issues become living documentation: 
        - Why we built it (Job Story)
        - How we designed it (Design comment)
        - How we implemented it (Task list, commits)
        - What we learned (Retrospective)
        - What's next (Follow-ups)
      </knowledge_base>
    </step>
  </task_process>

  <llm_integration>
    <how_llm_reads_issues>
      <approach_a>
        <name>Manual Copy-Paste</name>
        <description>Developer copies issue content to LLM chat</description>
        
        <workflow>
          Developer: "Here's the issue: 
          [pastes issue body]
          
          Here's the design comment:
          [pastes design comment]
          
          Help me implement task 3"
          
          LLM: [Generates implementation guidance]
        </workflow>

        <pros>Works with any LLM (no API needed)</pros>
        <cons>Manual, repetitive, error-prone</cons>
      </approach_a>

      <approach_b>
        <name>GitHub CLI + LLM</name>
        <description>Use gh CLI to fetch issue, pipe to LLM</description>
        
        <workflow>
          ```bash
          # Fetch issue as markdown
          gh issue view 42 --json body,comments \
            | jq -r '.body, (. comments[].body)' \
            | llm prompt implement-task-3.txt
          ```
        </workflow>

        <pros>Automated, always up-to-date</pros>
        <cons>Requires CLI setup, shell scripting</cons>
      </approach_b>

      <approach_c>
        <name>LLM with GitHub Integration</name>
        <description>LLM directly reads GitHub issues via API</description>
        
        <workflow>
          Developer: "LLM, read issue co0p/4dc#42 and help me with task 3"
          
          LLM: [Uses GitHub API to fetch issue, reads body and comments, generates guidance]
        </workflow>

        <pros>Seamless, no manual work</pros>
        <cons>Requires LLM with GitHub API access (Claude, ChatGPT, Copilot)</cons>
      </approach_c>

      <recommendation>
        Start with Approach A (manual) to validate workflow. 
        Graduate to Approach C when using GitHub Copilot or API-enabled LLM.
      </recommendation>
    </how_llm_reads_issues>

    <how_llm_writes_to_issues>
      <approach_a>
        <name>Manual Copy-Paste</name>
        <description>LLM generates content, developer pastes as comment</description>
        
        <workflow>
          LLM: "Here's the design comment:
          [generates design content]
          
          Copy this and add as a comment to issue #42"
          
          Developer:  [Copies to GitHub, posts comment]
        </workflow>
      </approach_a>

      <approach_b>
        <name>GitHub CLI</name>
        <description>Developer uses gh CLI to post comments</description>
        
        <workflow>
          ```bash
          # LLM generates content to file
          llm "generate design for issue 42" > design.md
          
          # Post as comment
          gh issue comment 42 --body-file design.md
          ```
        </workflow>
      </approach_b>

      <approach_c>
        <name>LLM with GitHub Integration</name>
        <description>LLM directly posts comments via API</description>
        
        <workflow>
          Developer:  "LLM, post this design as a comment to issue #42"
          
          LLM: [Uses GitHub API to create comment]
          LLM: "Posted design comment: https://github.com/co0p/4dc/issues/42#issuecomment-123"
        </workflow>
      </approach_c>

      <recommendation>
        Use Approach A (manual) initially. 
        Approach C is ideal but requires GitHub API permissions.
      </recommendation>
    </how_llm_writes_to_issues>

    <context_management>
      <challenge>
        LLM needs context from multiple sources:
        - Issue body (increment)
        - Design comment
        - Implementation progress comment
        - Codebase (current state)
        - Patterns (PATTERNS.md)
      </challenge>

      <solution>
        <step>Developer provides context explicitly</step>
        
        <example>
          Developer: "Context for task 3 of issue #42:
          
          Increment:  [paste Job Story and scenarios]
          Design: [paste key decisions]
          Current progress:  Completed tasks 1-2, starting task 3
          Relevant code: [paste state. js]
          Patterns: Read-Modify-Save-Render
          
          Help me implement task 3: Wire delete button"
          
          LLM: [Generates RED-GREEN-REFACTOR steps with full context]
        </example>
      </solution>
    </context_management>
  </llm_integration>

  <issue_templates>
    <increment_template>
      <filename>. github/ISSUE_TEMPLATE/increment.md</filename>
      
      <content>
        ---
        name:  Increment
        about: Define a new increment (WHAT and WHY)
        title: '[Increment] '
        labels: increment
        assignees: ''
        ---

        ## Job Story

        **When** 
        **I want to** 
        **So I can** 

        ## Acceptance Criteria

        ```gherkin
        Scenario: 
          Given 
          When 
          Then 
        ```

        ## Success Signals

        - [ ] 

        ## Out of Scope

        - 

        ## Assumptions

        - 

        ## Risks

        - 
          - Mitigation: 

        ---

        ## Progress Tracker

        - [ ] Increment defined
        - [ ] Design approved
        - [ ] Implementation complete
        - [ ] PR merged
        - [ ] Retrospective complete

        ## Links

        - PR: 
        - Commits: 
        - Patterns: 
        - Follow-ups: 
      </content>
    </increment_template>

    <refactoring_template>
      <filename>.github/ISSUE_TEMPLATE/refactoring.md</filename>
      
      <content>
        ---
        name:  Refactoring
        about:  Code improvement (no behavior change)
        title: '[Refactor] '
        labels: refactoring, implement
        assignees: ''
        ---

        ## What to Refactor

        [Description of code to improve]

        ## Why

        [Rationale - what's the problem with current code? ]

        ## Proposed Approach

        [How to improve it]

        ## Benefit / Effort / Risk

        - **Benefit:** [High/Medium/Low]
        - **Effort:** [Small/Medium/Large - time estimate]
        - **Risk:** [Low/Medium/High]

        ## Tests

        - [ ] All existing tests pass after refactoring
        - [ ] No behavior changes (pure refactor)

        ## Links

        - From retrospective: [issue link]
      </content>
    </refactoring_template>

    <pattern_template>
      <filename>. github/ISSUE_TEMPLATE/pattern.md</filename>
      
      <content>
        ---
        name: Pattern Documentation
        about: Document an emergent pattern
        title: '[Pattern] '
        labels: pattern
        assignees: ''
        ---

        ## Pattern Name

        [Name]

        ## Observed In

        - [Issue/file reference 1]
        - [Issue/file reference 2]
        - [Issue/file reference 3]

        ## Description

        [What is the pattern?]

        ## When to Use

        [Situations where this pattern applies]

        ## Example

        ```[language]
        // Code example
        ```

        ## Benefits

        - 

        ## Trade-offs

        - 

        ## Action

        - [ ] Create pattern card in patterns/[name].md
        - [ ] Reference from relevant code comments
      </content>
    </pattern_template>
  </issue_templates>

  <example_workflow>
    <scenario>
      <description>Complete workflow for "Delete Todo with Undo" increment</description>

      <timeline>
        <day number="1">
          <time>09:00</time>
          <actor>Developer</actor>
          <action>Creates issue #42 "Delete Todo with Undo" using increment template</action>
          <labels>increment</labels>

          <time>09:15</time>
          <actor>Developer + LLM</actor>
          <action>Refines increment in chat, fills out issue body (Job Story, Gherkin scenarios)</action>
          <result>Issue body complete</result>

          <time>09:30</time>
          <actor>Developer</actor>
          <action>Adds comment:  "‚úÖ Increment complete, ready for design"</action>
          <labels>design</labels>

          <time>10:00</time>
          <actor>LLM</actor>
          <action>Reads issue #42, posts design comment with STOP 1 summary</action>
          <result>Design comment (summary) posted</result>

          <time>10:15</time>
          <actor>Developer</actor>
          <action>Responds to STOP 1: "Looks good, proceed"</action>

          <time>10:30</time>
          <actor>LLM</actor>
          <action>Edits design comment to add full design (architecture, contracts, tests)</action>
          <result>Design comment complete</result>

          <time>11:00</time>
          <actor>Developer</actor>
          <action>Reviews design, adds comment: "‚úÖ Design approved, ready for implementation"</action>
          <labels>implement</labels>
        </day>

        <day number="2">
          <time>09:00</time>
          <actor>LLM</actor>
          <action>Posts implementation comment with task checklist (10 tasks)</action>
          <result>Implementation tracking comment added</result>

          <time>09:30</time>
          <actor>Developer + LLM</actor>
          <action>Work through tasks 1-3 using TDD, commit after each</action>
          <result>Tasks 1-3 checked off, commits linked</result>

          <time>14:00</time>
          <actor>Developer</actor>
          <action>Updates implementation comment:  "3/10 tasks complete, pausing for today"</action>
        </day>

        <day number="3">
          <time>09:00</time>
          <actor>Developer + LLM</actor>
          <action>Resume from task 4, work through remaining tasks</action>
          <result>All 10 tasks complete</result>

          <time>15:00</time>
          <actor>Developer</actor>
          <action>Creates PR #125 with body "Closes #42"</action>
          <action>Adds comment to issue: "‚úÖ Implementation complete, PR #125"</action>
          <labels>in-review</labels>
        </day>

        <day number="4">
          <time>10:00</time>
          <actor>Team</actor>
          <action>Reviews PR, approves</action>

          <time>11:00</time>
          <actor>Developer</actor>
          <action>Merges PR #125</action>
          <result>GitHub auto-closes issue #42</result>

          <time>11:15</time>
          <actor>Developer</actor>
          <action>Re-opens issue #42, adds comment: "‚úÖ Merged in PR #125, ready for retrospective"</action>
          <labels>improve</labels>

          <time>14:00</time>
          <actor>Developer + LLM</actor>
          <action>LLM reads full issue history + merged code, generates retrospective comment</action>
          <result>Retrospective comment with scorecard posted</result>

          <time>14:30</time>
          <actor>Developer</actor>
          <action>Reviews retrospective, creates follow-up issues: </action>
          <issues_created>
            <issue>#126:  Document pendingDelete pattern (immediate)</issue>
            <issue>#127: Extract event handler helpers (next increment)</issue>
            <issue>#128: Configurable timeout (backlog)</issue>
          </issues_created>

          <time>15:00</time>
          <actor>Developer</actor>
          <action>Updates retrospective comment with follow-up links</action>
          <action>Adds comment: "‚úÖ Retrospective complete"</action>
          <action>Closes issue #42</action>
          <labels>done</labels>
          <state>Closed</state>
        </day>
      </timeline>

      <final_issue_state>
        <issue_number>42</issue_number>
        <title>Delete Todo with Undo</title>
        <state>Closed</state>
        <labels>done, feature</labels>
        
        <body>
          [Complete increment definition with Job Story, Gherkin, Success Signals, etc.]
        </body>

        <comments>
          <comment>‚úÖ Increment complete, ready for design</comment>
          <comment>üèóÔ∏è Design (with architecture, contracts, decisions)</comment>
          <comment>‚úÖ Design approved, ready for implementation</comment>
          <comment>‚úÖ Implementation Progress (task checklist with commits)</comment>
          <comment>‚úÖ Implementation complete, PR #125</comment>
          <comment>‚úÖ Merged in PR #125, ready for retrospective</comment>
          <comment>üìä Retrospective (Beck's Scorecard, learnings, follow-ups)</comment>
          <comment>‚úÖ Retrospective complete</comment>
        </comments>

        <linked_prs>
          <pr number="125" state="merged">Implementation of delete with undo</pr>
        </linked_prs>

        <linked_issues>
          <issue number="126">Document pendingDelete pattern</issue>
          <issue number="127">Extract event handler helpers</issue>
          <issue number="128">Configurable timeout</issue>
        </linked_issues>
      </final_issue_state>
    </scenario>
  </example_workflow>

  <benefits>
    <benefit>
      <name>Async Collaboration</name>
      <description>
        Multiple developers can see and contribute to increment at any time. 
        Comments preserve full conversation history.
      </description>
    </benefit>

    <benefit>
      <name>Pause and Resume</name>
      <description>
        Developer can close laptop mid-increment. 
        All context is in issue - can pick up exactly where they left off.
      </description>
    </benefit>

    <benefit>
      <name>Team Visibility</name>
      <description>
        Anyone can see what's being worked on (label: implement).
        Anyone can see what's blocked (comments explain blockers).
        Anyone can see what was learned (retrospective comments).
      </description>
    </benefit>

    <benefit>
      <name>Searchable History</name>
      <description>
        "Why did we use setTimeout instead of setInterval?"
        ‚Üí Search issues for "setTimeout" ‚Üí Find design comment with rationale
      </description>
    </benefit>

    <benefit>
      <name>Living Documentation</name>
      <description>
        Issues capture not just WHAT was built, but WHY and HOW. 
        Future developers can understand decisions by reading issue history.
      </description>
    </benefit>

    <benefit>
      <name>Linked Knowledge Graph</name>
      <description>
        Issues link to: 
        - PRs (code changes)
        - Commits (specific implementations)
        - Follow-up issues (future work)
        - Pattern cards (documented patterns)
        
        Creates navigable knowledge graph.
      </description>
    </benefit>

    <benefit>
      <name>No External Tools Needed</name>
      <description>
        Everything lives in GitHub (where code already lives).
        No separate wiki, Confluence, Notion, etc.
        One tool, one source of truth.
      </description>
    </benefit>
  </benefits>

  <challenges_and_solutions>
    <challenge>
      <problem>Issues can become very long (many comments)</problem>
      <solution>
        Use structured comment headers (üèóÔ∏è Design, ‚úÖ Implementation).
        Link to specific comments (#issuecomment-123).
        Collapse old comments in GitHub UI.
      </solution>
    </challenge>

    <challenge>
      <problem>Hard to see "current state" in long thread</problem>
      <solution>
        Update issue body Progress Tracker checkboxes.
        Pin important comments (design, implementation progress).
        Use labels to show current phase.
      </solution>
    </challenge>

    <challenge>
      <problem>LLM loses context in long threads</problem>
      <solution>
        Developer provides focused context when asking for help.
        LLM reads specific comments (design, implementation) not entire thread.
        Use comment permalinks to reference specific decisions.
      </solution>
    </challenge>

    <challenge>
      <problem>Not all work maps to issues (spikes, experiments)</problem>
      <solution>
        Create "Spike" issue type for investigations.
        Close without merge if experiment fails.
        Capture learnings in closing comment.
      </solution>
    </challenge>

    <challenge>
      <problem>Copy-pasting issue content to LLM is tedious</problem>
      <solution>
        Use GitHub CLI scripts to fetch and format. 
        Use LLMs with GitHub API integration (Copilot, Claude with MCP).
        Create aliases/shortcuts for common operations.
      </solution>
    </challenge>
  </challenges_and_solutions>

  <recommended_setup>
    <github_settings>
      <setting>Enable issue templates in . github/ISSUE_TEMPLATE/</setting>
      <setting>Create labels:  increment, design, implement, in-review, improve, done</setting>
      <setting>Create project board with columns: Backlog, Increment, Design, Implement, Review, Improve, Done</setting>
      <setting>Enable auto-linking (PR "Closes #N" auto-closes issue on merge)</setting>
    </github_settings>

    <repository_structure>
      <structure>
        . github/
          ISSUE_TEMPLATE/
            increment.md
            refactoring.md
            pattern. md
        patterns/
          README.md (index)
          [pattern-cards]. md
        docs/
          retrospectives/ (optional - for exported retrospectives)
      </structure>
    </repository_structure>

    <workflow_documentation>
      <file>CONTRIBUTING.md</file>
      <content>
        # Contributing

        We use issue-driven development with the 4DC workflow: 

        1. **Increment** - Define WHAT and WHY in issue body
        2. **Design** - Define HOW in design comment
        3. **Implement** - Build using TDD, track in implementation comment
        4. **Improve** - Retrospective in improve comment

        See [example issue #42](link) for complete workflow.

        ## Creating an Increment

        1. Click "New Issue"
        2. Choose "Increment" template
        3. Fill in Job Story and Gherkin scenarios
        4. Label:  `increment`

        ## Working with LLM

        You can use LLM to help at each phase: 
        - Increment: Generate scenarios
        - Design: Propose architecture
        - Implement: Guide TDD cycles
        - Improve: Generate retrospective

        See `prompts/` folder for LLM prompts. 
      </content>
    </workflow_documentation>
  </recommended_setup>

  <output_format>
    <for_developer>
      This prompt is a guide, not an executable script. 
      
      Use it to:
      - Understand issue-driven workflow
      - Structure your GitHub issues
      - Know when to add comments vs update body
      - Track progress through labels
      - Integrate LLM at each phase
    </for_developer>

    <for_llm>
      When asked to help with GitHub issues: 
      
      1. Determine current phase from issue labels
      2. Read relevant issue content (body for increment, comments for design/implement/improve)
      3. Apply appropriate prompt (INCREMENT, DESIGN, IMPLEMENT, IMPROVE)
      4. Generate content formatted for GitHub (Markdown, Mermaid)
      5. Instruct developer to post as comment or update body
      6. Suggest label transitions when phase completes
    </for_llm>
  </output_format>

  <final_reminder>
    GitHub Issues are not just tickets - they are living documents. 
    
    Each issue tells the complete story: 
    - Why we built it (Job Story)
    - What success looks like (Gherkin)
    - How we designed it (Design comment)
    - How we built it (Implementation comment + commits)
    - What we learned (Retrospective comment)
    - What's next (Follow-up issues)
    
    This creates a searchable, navigable knowledge base that grows with your codebase.
    
    The team benefits from:
    - Visibility (see what's being worked on)
    - Context (understand decisions)
    - Collaboration (contribute to any increment)
    - Learning (read retrospectives)
    
    The developer benefits from:
    - Focus (one increment at a time)
    - Continuity (pause/resume with full context)
    - Guidance (LLM helps at each phase)
    - Growth (track quality trends via scorecards)
  </final_reminder>
</prompt>